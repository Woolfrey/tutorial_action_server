#include <tutorial_action_definition/action/fibonacci.hpp>                                          // Generated by tutorial_action_definition pkg
#include <rclcpp/rclcpp.hpp>
#include <rclcpp_action/rclcpp_action.hpp>


class FibonacciServer : public rclcpp::Node
{
   public:
      using Fibonacci  = tutorial_action_definition::action::Fibonacci;                             // Makes referencing easier
      using GoalHandle = rclcpp_action::ServerGoalHandle<Fibonacci>;
      
      /**
       * Constructor.
       */
      FibonacciServer(const rclcpp::NodeOptions &options = rclcpp::NodeOptions())
      :
      Node("fibonacci_server_node", options)
      {
           this->_actionServer
           = rclcpp::action::create_server<Fibonacci>(this,                                                  // Connect to this node
                                                      "fibonacci",                                           // Advertise action name
                                                      std::bind(&FibonacciServer::handle_goal,this,_1,_2),   // Callback function for action request
                                                      std::bind(&FibonacciServer::handle_cancel,this,_1),    // Callback function for canceling action
                                                      std::bind(&FibonacciServer::handle_accepted,this,_1)); // Callback function when goal is accepted
      }
      
   private:
      
      rclcpp_action::Server<Fibonacci> _actionServer;
      
      /**
       * Function for requesting Fibonacci calculation.
       * @param goal An integer specifying which number in the sequence.
       */
      rclcpp_action::GoalResponse handle_goal(const rclcpp_action::GoalUUID &uuid,
                                              const Fibonacci::Goal &goal)
      {
         RCLCPP_INFO(this->get_logger(), "Requested to compute Fibonacci sequence up to order %d", goal->order); // Inform user
         
         (void)uuid;                                                                                // I don't know what this does ¯\_(ツ)_/¯
         
         return rclcpp::ACCEPT_AND_EXECUTE;
      }
      
      /**
       * Function for cancelling an action under execution.
       * @goalHandle
       */
      rclcpp_action::CancelResponse handle_cancel(const GoalHandleFibonacci &goalHandle)
      {
         RCLCPP_INFO(this->get_logger(), "Received request to cancel goal.");                       // Inform user
         
         (void)goal_handle;                                                                         // I don't know what this does ¯\_(ツ)_/¯
         
         return rclcpp_action::CancelResponse::ACCEPT;
      }
      
      /**
       * Function for when a goal is accepted for execution.
       *
       */
      void handle_accepted(const GoalHandleFibonacci goalHandle)
      {
         std::thread{std::bind(&FibonacciServer::execute, this, _1), goalHandle}.detach();          // Link to execute() function below
      }
      
      /**
       * Principle control thread which computes the Fibonacci sequence.
       */
      void execute(const GoalHandleFibonacci goalHandle)
      {
         RCLCPP_INFO(this->get_logger(), "Executing goal.");
         
         rclcpp::Rate loopRate(1);                                                                  // Set a frequency of 1Hz for this thread
         
         int goal = goalHandle->get_goal();                                                         // Obtain the goal
         
         auto feedback = Fibonacci::Feedback;
         
         int sequence[] = feedback.partial_sequence;
         
         sequence.push_back(0);
         
         sequence.push_back(1);
         
         auto result = Fibonacci::Result;
         
         for(int i = 1; i < goal.order) && rclcpp::ok(); i++)
         {
            // Check for cancellation
            if(goalHandle.is_cancelling())
            {
               result.sequence = sequence;                                                          // Put the current sequence as the result
               
               goalHandle.canceled(result);                                                         // 
      }
};                                                                                                  // Semicolon required after class definition
